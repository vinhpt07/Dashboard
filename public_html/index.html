<!DOCTYPE html>
<html>
    <head>
        <title>NexGen DashBoard</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <script src="https://d3js.org/d3.v4.min.js"></script>
        <style>





text {
  font: bold 36px monospace;
}

.enter {
  fill: green;
}

.update {
  fill: #333;
}

.exit {
  fill: brown;
}






    </style>
    </head>

    <body>
        <svg width="1200" height="700">

        </svg>
    </body>
<script>
//var alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
//
var data = [  
   {"percent" : 1,"color":"gray","opacity":"0.3","value":1000,"x":150,"y":100,"r":100},
   {"percent" : 0.2942,"color":"orange","opacity":"1","value":295,"x":150,"y":100,"r":100},
   {"percent" : 1,"color":"gray","opacity":"0.3","value":192,"x":550,"y":100,"r":100},
   {"percent" : 0.2942,"color":"orange","opacity":"1","value":56,"x":550,"y":100,"r":100},
   {"percent" : 1,"color":"gray","opacity":"0.3","value":32,"x":950,"y":100,"r":100},
   {"percent" : 0.2942,"color":"orange","opacity":"1","value":9,"x":950,"y":100,"r":100}
];
var image = [
    {"href":"img/typing.png","x":100,"y":50},
    {"href":"img/checking.png","x":500,"y":50},
    {"href":"img/users.png","x":900,"y":50}
];
var package = [
    {"volume":1000,"keyed":100},{"volume":1000,"keyed":0}
];

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height"),
    g = svg.append("g").attr("transform", "translate(100," + (height / 2) + ")");
    g2 = svg.append("g").attr("transform", "translate(100,0)").attr("id","bar");
    g3 = svg.append("g").attr("transform", "translate(100,0)");
    //<path id="arc1" fill="none" stroke="#446688" stroke-width="20" d="M 50 150 A 100 100 0 1 0 150 50"></path>
var   count = package.length,
      cx = width/2,
      cy = height/4,
      limit  = 5,
      stdLen = count<=limit ? width/limit:width/limit,
      stdHei = 20
      ;
    function triangle(selector,percent,num){
        if (num>limit) return;
        var dime;
        var x = d3.select("#bar").selectAll("path").filter(function(d, i) { return i === num; });
            dime = x
                .attr("d").replace("M","")
                .replace("L",",").split(",");
            dime[0]=dime[2]=parseFloat(dime[0])+(parseFloat(dime[2])-parseFloat(dime[0]))*parseFloat(percent)/100;
            dime[3]=parseFloat(dime[3])-100;
//        var context = selector.selectAll("path").data([0]);
//            context.attr("d","M"+dime[0]+" "+dime[1]+" L"+dime[2]+" "+dime[3]);
//            context.enter().append("path")
//                .attr("d","M"+dime[0]+" "+dime[1]+" L"+dime[2]+" "+dime[3])
//                .attr("stroke","red");
        var context = selector.selectAll("image").data([0]);

                 context.transition().duration(1000)
                //.attr("xlink:href", "img/runner2.gif")
                .attr("x", dime[0])
                .attr("y", parseFloat(dime[1])-30)
                //.attr("width", "20")
                //.attr("height", "20")
                ;
                context.enter()
                .append("svg:image")
                .attr("xlink:href", "img/runner2.gif")
                .attr("x", dime[0])
                .attr("y", parseFloat(dime[1])-30)
                .attr("width", "20")
                .attr("height", "20");
    }  
    function drawCircle(x,y,radius,percent){
        var context = d3.path();
        context.arc(x,y,radius,percent*1.7*Math.PI,0.5*Math.PI,true);
        return context.toString();
    }
    function drawLine(x,y,dx,dy){
        var context = d3.path();
        context.moveTo(x,y);
        context.lineTo(dx,dy);
        return context.toString();
    }
    function update(){
      var t = g.transition()
      .duration(750)
      .on("start", function repeat() {
        d3.active(this).selectAll("path").filter(":nth-child(even)")
            .style("stroke", "purple")
          .transition()
            .style("stroke", "blue")
          .transition()
           .on("start", repeat) ;
      });

    //Circles added to the circleGroup
    var circles = g.selectAll("path")
                             .data(data);
                             
                             
    circles.transition(t)
           
             .attr("d",function(d){return drawCircle(d.x,d.y,d.r,d.percent);})
             
             .attr("stroke-width","1")
             .attr("fill","none")
             .attr("opacity",function(d){return d.opacity;})
             
             .attr("stroke",function(d){return d.color;})
             .attr("stroke-width","11");

    circles.enter().append("path")
                .attr("d",function(d){return drawCircle(d.x,d.y,d.r,d.percent);})
                
                .attr("stroke-width","1")
                .transition(t)
                .attr("fill","none")
                .attr("opacity",function(d){return d.opacity;})          
                .attr("stroke",function(d){return d.color;})
                .attr("stroke-width","11");
          
    var texts_even = g.selectAll("text").filter(":nth-child(even)")
            .data([data[1],data[3],data[5]]);
    var texts_odd = g.selectAll("text").filter(":nth-child(odd)")
            .data(data);
        texts_even
                .text(function(d){return d.value;})
                .attr("dx", function(d){return d.percent===1? d.x+0.8*d.r:d.x-20;})
                .attr("dy", function(d){return d.percent===1? d.y-d.r:d.y+1.8*d.r;})
                .attr("opacity",function(d){return d.opacity;})          
                .attr("stroke",function(d){return d.color;})
                .attr("fill",function(d){return d.color;});    
        g.selectAll("text").data(data).enter().append("text")
                .text(function(d){return d.value;})
                .attr("dx", function(d){return d.percent===1? d.x+0.8*d.r:d.x-20;})
                .attr("dy", function(d){return d.percent===1? d.y-d.r:d.y+1.8*d.r;})
                .attr("opacity",function(d){return d.opacity;})          
                .attr("stroke",function(d){return d.color;})
                .attr("fill",function(d){return d.color;});
     var imgs = g.selectAll("image").data(image);
                imgs.enter()
                .append("svg:image")
                .attr("xlink:href", function(d){return d.href;})
                .attr("x", function(d){return d.x;})
                .attr("y", function(d){return d.y;})
                .attr("width", "100")
                .attr("height", "100");
        ;
    }
    var getGradient = function(percent,i){
        if (i>limit) return;
        if (document.getElementById("gradient"+i)!==null) {
            svg.select("#gradient"+i+">stop").attr("offset",percent+'%');
            if (parseFloat(percent)>0 && parseFloat(percent)!==100) triangle(g3,percent,i);
            return "url(#gradient"+i+")";
        }
        gradient = svg.append("svg:defs")
       .append("svg:linearGradient")
       .attr("id", "gradient"+i)
       .attr("x1", "0%")
       .attr("y1", "0%")
       .attr("x2", "100%")
       .attr("y2", "0%")
       .attr("spreadMethod", "pad")
       ;

       gradient.append("svg:stop")
       .attr("offset", percent+'%')
       .attr("stop-color", "darkgreen")
       .attr("stop-opacity", 1);

       gradient.append("svg:stop")
       .attr("offset", "0%")
       .attr("stop-color", "gray")
       .attr("stop-opacity", 0.3);
       return "url(#gradient"+i+")";
    };
 
    function update_line(){
          var t = g2.transition()
          .duration(750)
//          .on("start", function repeat() {
//            d3.active(this).selectAll("path").filter(":nth-child(even)")
//                .style("stroke", "purple")
//              .transition()
//                .style("stroke", "blue")
//              .transition()
//               .on("start", repeat) ;
//          })
;
    var dim = analyze();
    var drawPackage = function(d,i){
        if (i>limit) return;
        return drawLine(dim[i].x,dim[i].y,dim[i].dx,dim[i].dy);         
    };
  
       
//        g2.selectAll("cirle").data([0])
//                .enter().append("circle")
//                .attr("cx",cx)
//                .attr("cy",cy)
//                .attr("r",3)
//                .attr("fill","black");
 
        //Circles added to the circleGroup
        var lines = g2.selectAll("path")
                                 .data(package);

//          lines.remove();                      
        lines
                 .attr("d",drawPackage)
                 .attr("stroke-width","1")
                 .attr("fill","none")
                 .attr("stroke",function(d,i){return getGradient(d.keyed*100/d.volume,i);})
                 .attr("stroke-width",stdHei)
         ;

        lines.enter().append("path")
                    .attr("d",drawPackage)                  
                    .attr("stroke-width","1")
                    .attr("fill","none")         
                    .attr("stroke",function(d,i){return getGradient(d.keyed*100/d.volume,i);})
                    .attr("stroke-width",stdHei)	
                    ;
//            var i = 0;
//            i++;
//            if (i == count) return;
//            update_line();
        }
        function analyze(){
            total_len = 0;
            ab =0;
            dimension =[];
            count = package.length;
            package.slice(0,limit+1).forEach(function(v){total_len += v.volume/1000;});
            count = count>limit+1?limit+1:count;
            for(i=0;i<count;i++){
                d={};
                d.x = cx+(i-total_len/2)*stdLen - (ab)*stdLen;
                d.y = cy+(-i+total_len/2)*stdHei;
                d.dx = cx+(i+package[i].volume/1000-total_len/2)*stdLen - (ab)*stdLen;
                d.dy = cy+(-i+total_len/2)*stdHei+0.01;
                ab += package[i].volume/1000 !== 1 ? 1 - package[i].volume/1000:0;
                dimension.push(d);
            }
            return dimension;
        }
//function update(data) {
//  var t = d3.transition()
//      .duration(750)
//      .on("start", function repeat() {
//        d3.active(this)
//            .style("background", "red")
//         // .transition()
//            //.style("background", "blue")
//          //.transition()
//            //.on("start", repeat);
//      });
//
//  // JOIN new data with old elements.
//  var text = g.selectAll("text")
//    .data(data, function(d) { return d; });
//
//  // EXIT old elements not present in new data.
//  text.exit()
//      .attr("class", "exit")
//    .transition(t)
//      .attr("y", 60)
//      .style("fill-opacity", 1e-6)
//      .remove();
//
//  // UPDATE old elements present in new data.
//  text.attr("class", "update")
//      .attr("y", 0)
//      .style("fill-opacity", 1)
//    .transition(t)
//      .attr("x", function(d, i) { return i * 32; });
//
//  // ENTER new elements present in new data.
//  text.enter().append("text")
//      .attr("class", "enter")
//      .attr("dy", ".35em")
//      .attr("y", -60)
//      .attr("x", function(d, i) { return i * 32; })
//      .style("fill-opacity", 1e-6)
//      .text(function(d) { return d; })
//    .transition(t)
//      .attr("y", 0)
//      .style("fill-opacity", 1);
//}
update();
update_line();

//
//// Grab a random sample of letters from the alphabet, in alphabetical order.
d3.interval(function() {
        data[1].value +=1;
        data[3].value +=1;
        data[5].value += data[5].value === data[4].value ? 0:1;
        data[1].percent = data[1].value/data[0].value;
        data[3].percent = data[3].value/data[2].value;
        data[5].percent = data[5].value/data[4].value>1 ? 0.999 : data[5].value/data[4].value;
        update();
        if(package.length < 10) package.push({"volume":d3.randomUniform(1000,1000)(),"keyed":d3.randomUniform(0,0)()});
        switch (true){
         case package[0].keyed < 1000:
             package[0].keyed +=100;
             break;
         case package[1].keyed < 1000:
             package[1].keyed +=100;
             break;
         case package[2].keyed < 1000:
             package[2].keyed +=100;
             break;
         case package[3].keyed < 1000:
             package[3].keyed +=100;
             break;
         default:
             if(package[4].keyed!==1000) package[4].keyed +=100;
     }     
        update_line();
        
}, 1500);
// The initial display.
//
</script>
</html>
